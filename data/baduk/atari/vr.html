
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Atari-Go in A-Frame VR</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-blink-controls/dist/aframe-blink-controls.min.js"></script>
</head>
<body>
  <a-scene>
    <!-- Environment -->
    <a-sky color="#87CEEB"></a-sky>
    <a-plane position="0 0 -5" rotation="-90 0 0" width="10" height="10" color="#2E8B57"></a-plane>
    
    <!-- Game Board Entity -->
    <a-entity id="game-board" 
              position="0 1.6 -3" 
              geometry="primitive: plane; width: 3; height: 3" 
              material="color: #f1d9a5"
              atari-go-game>
    </a-entity>
    
    <!-- Camera with Controls -->
    <a-entity id="cameraRig">
      <a-entity camera position="0 1.6 0" look-controls></a-entity>
      <a-entity laser-controls="hand: left"></a-entity>
      <a-entity laser-controls="hand: right"></a-entity>
    </a-entity>
    
    <!-- Lighting -->
    <a-light type="ambient" color="#BBB"></a-light>
    <a-light type="directional" color="#FFF" position="-1 3 2"></a-light>
  </a-scene>

  <script>
    // Register the Atari-Go Web Component
    AFRAME.registerComponent('atari-go-game', {
      schema: {},
      
      init: function() {
        this.createGameCanvas();
        this.setupEventListeners();
      },
      
      createGameCanvas: function() {
        const canvas = document.createElement('canvas');
        canvas.width = 450;
        canvas.height = 450;
        canvas.id = 'vr-atari-go';
        
        // Hide canvas from regular DOM but keep it for rendering
        canvas.style.display = 'none';
        document.body.appendChild(canvas);
        
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.setupGameLogic();
        this.drawBoard();
      },
      
      setupGameLogic: function() {
        const SIZE = 9;
        const GRID = 50;
        const R = 18;
        
        this.SIZE = SIZE;
        this.GRID = GRID;
        this.R = R;
        this.board = Array.from({length: SIZE}, _ => Array(SIZE).fill(0));
        this.turn = 1;
        this.cursor = {x: 4, y: 4};
        this.gameOver = false;
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        // Apply texture to the entity's material
        this.el.setAttribute('material', {
          src: texture,
          transparent: false
        });
        
        this.texture = texture;
      },
      
      drawBoard: function() {
        const ctx = this.ctx;
        const SIZE = this.SIZE;
        const GRID = this.GRID;
        const R = this.R;
        const board = this.board;
        
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw board grid
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for(let i = 0; i < SIZE; i++) {
          ctx.moveTo(GRID/2 + i * GRID, GRID/2);
          ctx.lineTo(GRID/2 + i * GRID, GRID/2 + (SIZE-1) * GRID);
          ctx.moveTo(GRID/2, GRID/2 + i * GRID);
          ctx.lineTo(GRID/2 + (SIZE-1) * GRID, GRID/2 + i * GRID);
        }
        ctx.stroke();
        
        // Draw star points
        const stars = [2, 4, 6];
        ctx.fillStyle = "#000";
        stars.forEach(ix => {
          stars.forEach(iy => {
            ctx.beginPath();
            ctx.arc(GRID/2 + ix * GRID, GRID/2 + iy * GRID, 4, 0, 2 * Math.PI);
            ctx.fill();
          });
        });
        
        // Draw stones
        for(let y = 0; y < SIZE; y++) {
          for(let x = 0; x < SIZE; x++) {
            if(board[y][x]) {
              this.drawStone(x, y, board[y][x]);
            }
          }
        }
        
        // Draw cursor
        if(!this.gameOver) {
          ctx.strokeStyle = "rgba(0,0,255,.6)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(GRID/2 + this.cursor.x * GRID, GRID/2 + this.cursor.y * GRID, R + 4, 0, 2 * Math.PI);
          ctx.stroke();
        }
        
        // Update texture
        this.texture.needsUpdate = true;
      },
      
      drawStone: function(x, y, color) {
        const ctx = this.ctx;
        const GRID = this.GRID;
        const R = this.R;
        const cx = GRID/2 + x * GRID;
        const cy = GRID/2 + y * GRID;
        
        const grd = ctx.createRadialGradient(cx - R/3, cy - R/3, 2, cx, cy, R);
        if(color === 1) {
          grd.addColorStop(0, "#666");
          grd.addColorStop(1, "#000");
        } else {
          grd.addColorStop(0, "#fff");
          grd.addColorStop(0.8, "#ddd");
          grd.addColorStop(1, "#bbb");
        }
        
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(cx, cy, R, 0, 2 * Math.PI);
        ctx.fill();
      },
      
      setupEventListeners: function() {
        // Handle click/touch events for placing stones
        this.el.addEventListener('click', (evt) => {
          if(this.gameOver) return;
          
          // Calculate board coordinates from click position
          const intersection = evt.detail.intersection;
          if(intersection) {
            const localPoint = intersection.point;
            // Convert from world coordinates to board coordinates
            const boardX = Math.round((localPoint.x + 1.5) * (this.SIZE - 1) / 3);
            const boardY = Math.round((1.5 - localPoint.y) * (this.SIZE - 1) / 3);
            
            if(boardX >= 0 && boardX < this.SIZE && boardY >= 0 && boardY < this.SIZE) {
              this.tryPlay(boardX, boardY);
            }
          }
        });
        
        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
          if(this.gameOver) return;
          
          switch(e.key) {
            case "ArrowLeft":
              this.cursor.x = Math.max(0, this.cursor.x - 1);
              break;
            case "ArrowRight":
              this.cursor.x = Math.min(this.SIZE - 1, this.cursor.x + 1);
              break;
            case "ArrowUp":
              this.cursor.y = Math.max(0, this.cursor.y - 1);
              break;
            case "ArrowDown":
              this.cursor.y = Math.min(this.SIZE - 1, this.cursor.y + 1);
              break;
            case " ":
              this.tryPlay(this.cursor.x, this.cursor.y);
              break;
            case "Shift":
              this.passTurn();
              break;
            default:
              return;
          }
          e.preventDefault();
          this.drawBoard();
        });
      },
      
      neighbors: function(x, y) {
        return [[x-1,y],[x+1,y],[x,y-1],[x,y+1]]
          .filter(([a,b]) => a >= 0 && a < this.SIZE && b >= 0 && b < this.SIZE);
      },
      
      flood: function(x, y, color, group = new Set(), libs = new Set()) {
        const SIZE = this.SIZE;
        const key = y * SIZE + x;
        if(group.has(key)) return {group, libs};
        group.add(key);
        for(const [nx, ny] of this.neighbors(x, y)) {
          if(this.board[ny][nx] === 0) libs.add(ny * SIZE + nx);
          else if(this.board[ny][nx] === color) {
            this.flood(nx, ny, color, group, libs);
          }
        }
        return {group, libs};
      },
      
      tryPlay: function(x, y) {
        if(this.board[y][x] !== 0) return false;
        
        this.board[y][x] = this.turn;
        
        let captured = 0;
        const opp = 3 - this.turn;
        for(const [nx, ny] of this.neighbors(x, y)) {
          if(this.board[ny][nx] === opp) {
            const {group, libs} = this.flood(nx, ny, opp);
            if(libs.size === 0) {
              for(const key of group) {
                const gx = key % SIZE;
                const gy = Math.floor(key / SIZE);
                this.board[gy][gx] = 0;
                captured++;
              }
            }
          }
        }
        
        const {libs} = this.flood(x, y, this.turn);
        if(libs.size === 0 && captured === 0) {
          this.board[y][x] = 0;
          return false;
        }
        
        if(captured > 0) {
          this.declareWinner(this.turn, captured);
        } else {
          this.nextTurn();
        }
        
        this.drawBoard();
        return true;
      },
      
      declareWinner: function(color, captured) {
        this.gameOver = true;
        console.log(`${color === 1 ? "Black" : "White"} wins by capturing ${captured} stone${captured > 1 ? "s" : ""}!`);
      },
      
      nextTurn: function() {
        this.turn = 3 - this.turn;
      },
      
      passTurn: function() {
        if(this.gameOver) return;
        this.nextTurn();
        this.drawBoard();
      },
      
      tick: function() {
        // Optional: Add animation or continuous updates here
      }
    });
  </script>
</body>
</html>
