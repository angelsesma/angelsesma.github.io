<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Musical Go Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    #game-container {
      border: 1px solid #ccc;
      box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1);
    }
    #ui-panel {
      width: 700px; /* Match canvas width */
      padding: 15px 0;
      display: flex;
      justify-content: space-around;
      align-items: center;
      background-color: #e0e0e0;
      border-bottom: 1px solid #ccc;
    }
    .status-box, .control-box {
      padding: 5px 10px;
      text-align: center;
    }
    button {
      padding: 8px 12px;
      margin: 3px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    .player-indicator {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="ui-panel">
    <div class="status-box" id="game-status"></div>
    <div class="control-box">
        <button id="play-sequence-btn">Play Sequence</button>
        <button id="pass-btn">Pass Turn</button>
        <button id="clear-btn">Clear Board</button>
    </div>
    <div class="status-box">
        <span id="tempo-display">Tempo: 120 BPM</span>
        <button id="tempo-up">+</button>
        <button id="tempo-down">-</button>
    </div>
  </div>
  <div id="game-container">
  <script>
let gridSize = 13;
let cellSize;
let boardSize;
let grid = [];

// Game state
let currentPlayer = 1; // 1 = bass (black), 2 = treble (white)
let passCount = 0;
let gameOver = false;
let koX = -1, koY = -1;

// Sound objects
let bassOsc, trebleOsc;
let playInterval = 500; // Time between sequence notes (milliseconds)
let lastPlayTime = 0;
let isPlayingSequence = false;
let sequence = [];
let currentSequenceIndex = 0;

// Colors
const boardColor = [210, 180, 130];
const lineColor = [0, 0, 0];
const starPointColor = [0, 0, 0];
const bassColor = [50, 50, 50]; // Black stones
const trebleColor = [240, 240, 240]; // White stones
const lastMoveColor = [255, 0, 0, 100];
const sequenceHighlightColor = [255, 255, 0, 180];

// Note frequencies
const bassFreqs = [65.41, 73.42, 82.41, 87.31, 98.00, 110.00, 123.47,
                  130.81, 146.83, 164.81, 174.61, 196.00, 220.00];
const trebleFreqs = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88,
                    523.25, 587.33, 659.25, 698.46, 783.99, 880.00];

function setup() {
  // Create canvas (700x700 for board, 50px for UI padding)
  let canvas = createCanvas(500, 500);
  canvas.parent('game-container');

  // Calculate cell size
  boardSize = min(width, height);
  cellSize = boardSize / (gridSize + 1);

  // Initialize the grid
  for (let i = 0; i < gridSize; i++) {
    grid[i] = [];
    for (let j = 0; j < gridSize; j++) {
      grid[i][j] = new Cell(i, j, cellSize);
    }
  }

  // Initialize sound oscillators
  bassOsc = new p5.SinOsc();
  trebleOsc = new p5.SinOsc();
  bassOsc.amp(0.5);
  trebleOsc.amp(0.5);

  // Set up UI event listeners
  document.getElementById('pass-btn').addEventListener('click', passTurn);
  document.getElementById('clear-btn').addEventListener('click', clearBoard);
  document.getElementById('play-sequence-btn').addEventListener('click', toggleSequencePlayback);
  document.getElementById('tempo-up').addEventListener('click', () => {
    playInterval = max(100, playInterval - 50);
    updateUIStatus();
  });
  document.getElementById('tempo-down').addEventListener('click', () => {
    playInterval = min(2000, playInterval + 50);
    updateUIStatus();
  });

  drawGoBoard();
  updateUIStatus();
}

function draw() {
  // Redraw static board background (necessary if stones are removed/captured)
  drawGoBoard();

  // Draw all stones
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      if (grid[i][j].state !== 0) {
        grid[i][j].display();
      }
    }
  }

  // Draw ko indicator
  if (koX !== -1) {
    fill(lastMoveColor);
    noStroke();
    ellipse((koX + 1) * cellSize, (koY + 1) * cellSize, 10, 10);
  }

  // Sequence playback
  if (isPlayingSequence && sequence.length > 0) {
    if (millis() - lastPlayTime > playInterval) {
      playNextInSequence();
      lastPlayTime = millis();
    }
  }
}

function drawGoBoard() {
  background(boardColor);
  stroke(lineColor);
  strokeWeight(1);

  // Draw grid lines
  for (let i = 0; i < gridSize; i++) {
    let x = (i + 1) * cellSize;
    let y = (i + 1) * cellSize;
    line(x, cellSize, x, boardSize - cellSize); // Vertical
    line(cellSize, y, boardSize - cellSize, y); // Horizontal
  }

  // Draw star points (hoshi)
  fill(starPointColor);
  noStroke();
  const starPoints = [3, 9, 6]; 

  for (let i of starPoints) {
    for (let j of starPoints) {
      let x = (i + 1) * cellSize;
      let y = (j + 1) * cellSize;
      ellipse(x, y, 8, 8);
    }
  }

  // Draw board border
  stroke(lineColor);
  strokeWeight(3);
  noFill();
  rect(cellSize, cellSize, boardSize - 2*cellSize, boardSize - 2*cellSize);
}

function updateUIStatus() {
    // Update game status
    let statusText;
    if (gameOver) {
        statusText = `<span style="color:red;">GAME OVER!</span>`;
    } else {
        const playerColor = currentPlayer === 1 ? 'background-color: rgb(50, 50, 50);' : 'background-color: rgb(240, 240, 240); border: 1px solid black;';
        statusText = `<span class="player-indicator" style="${playerColor}"></span> ${currentPlayer === 1 ? "BASS (Black)" : "TREBLE (White)"}'s turn`;
    }
    document.getElementById('game-status').innerHTML = statusText + `<br>Sequence: ${sequence.length} notes`;

    // Update tempo status
    document.getElementById('tempo-display').textContent = `Tempo: ${Math.round(60000 / playInterval)} BPM`;
    
    // Update sequence button text
    document.getElementById('play-sequence-btn').textContent = isPlayingSequence ? "Stop Sequence" : "Play Sequence";
}

function mousePressed() {
  if (gameOver) return;

  // Determine which cell was clicked
  let col = round((mouseX - cellSize) / cellSize);
  let row = round((mouseY - cellSize) / cellSize);

  // Check bounds
  if (col >= 0 && col < gridSize && row >= 0 && row < gridSize) {
    
    // Clear all lastMove markers
    for(let i=0; i<gridSize; i++) {
      for(let j=0; j<gridSize; j++) {
        grid[i][j].lastMove = false;
      }
    }

    if (isValidMove(col, row)) {
      // 1. Place the stone
      grid[col][row].state = currentPlayer;
      grid[col][row].lastMove = true;

      let capturedCount = 0;
      
      // 2. Check for captures (MUST happen BEFORE suicide check)
      capturedCount += checkCaptures(col, row);

      // 3. Play sound only if valid (and add to sequence)
      playNote(col, row, currentPlayer);
      sequence.push(grid[col][row]);

      // 4. Update ko position
      koX = -1;
      koY = -1;

      // Check for ko (simple implementation: if exactly one stone was captured)
      if (capturedCount === 1) {
        // Need to identify where the captured stone was, this is complex without tracking board history.
        // For simplicity, we flag the last move as a potential KO source for the opponent's next move.
        // NOTE: A proper KO implementation requires tracking board history (history of full board states).
        // Since we aren't tracking history, we rely on the `isValidMove` logic checking if a move would recapture a single stone that was just placed.
      }


      // 5. Switch player
      currentPlayer = 3 - currentPlayer;
      passCount = 0;
      updateUIStatus();
    }
  }
}

// Helper to convert Cell objects into a state integer array for DFS checks
function extractStateArray(currentGrid) {
    let stateArray = [];
    for (let i = 0; i < gridSize; i++) {
        stateArray[i] = [];
        for (let j = 0; j < gridSize; j++) {
            stateArray[i][j] = currentGrid[i][j].state;
        }
    }
    return stateArray;
}

function isValidMove(x, y) {
  if (grid[x][y].state !== 0) return false;

  // 1. Check Ko rule
  if (x === koX && y === koY) return false;

  // Create temporary board state for simulation
  let tempBoard = extractStateArray(grid);
  tempBoard[x][y] = currentPlayer;
  
  // 2. Suicide Check: Does the placement have liberties OR capture an opponent?
  
  let wouldCapture = false;
  let opponent = 3 - currentPlayer;

  // Check if placement captures an opponent group
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (abs(dx) + abs(dy) !== 1) continue;

      let nx = x + dx;
      let ny = y + dy;

      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
        if (tempBoard[nx][ny] === opponent) {
          if (countLiberties(tempBoard, nx, ny) === 0) {
            wouldCapture = true;
            // Capture occurs in the temporary board before final suicide check
            // (We don't actually capture here, we just check if a capture *would* occur)
            // If it captures, it's NOT suicide.
          }
        }
      }
    }
  }

  // If the move captures, it's valid regardless of its own liberty count.
  if (wouldCapture) return true;

  // If no capture, check if the placed group has liberties (non-suicide)
  if (countLiberties(tempBoard, x, y) > 0) return true;

  // If it doesn't capture AND it has zero liberties, it's illegal (suicide)
  return false;
}

// Checks adjacent opponent groups for zero liberties and performs captures
function checkCaptures(x, y) {
  let capturedCount = 0;
  let opponent = 3 - currentPlayer;
  let currentState = extractStateArray(grid); // Use the grid *after* placement

  // Check all adjacent opponent groups
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (abs(dx) + abs(dy) !== 1) continue;

      let nx = x + dx;
      let ny = y + dy;

      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
        if (grid[nx][ny].state === opponent) {
          // Check if this group has no liberties
          if (countLiberties(currentState, nx, ny) === 0) {
            capturedCount += captureGroup(nx, ny);
          }
        }
      }
    }
  }
  return capturedCount;
}

function captureGroup(x, y) {
  let captured = 0;
  // Use a stack for DFS to find the entire group to be captured
  let stack = [[x, y]];
  let visited = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
  let targetState = grid[x][y].state;

  while (stack.length > 0) {
    let current = stack.pop();
    let cx = current[0];
    let cy = current[1];

    if (visited[cx][cy]) continue;
    visited[cx][cy] = true;

    if (grid[cx][cy].state === targetState) {
      // Remove stone and update sequence
      grid[cx][cy].state = 0;
      grid[cx][cy].lastMove = false;
      captured++;

      let index = sequence.indexOf(grid[cx][cy]);
      if (index !== -1) {
          sequence.splice(index, 1);
      }

      // Check neighbors
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (abs(dx) + abs(dy) !== 1) continue;

          let nx = cx + dx;
          let ny = cy + dy;

          if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
            if (!visited[nx][ny] && grid[nx][ny].state === targetState) {
              stack.push([nx, ny]);
            }
          }
        }
      }
    }
  }
  return captured;
}


// Counts liberties of a group starting at (x, y) on the provided board state (integer array)
function countLiberties(board, x, y) {
  if (board[x][y] === 0) return 0;

  let visited = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
  let targetState = board[x][y];
  let liberties = new Set(); // Use a Set to count unique liberty points

  let stack = [[x, y]];

  while (stack.length > 0) {
    let current = stack.pop();
    let cx = current[0];
    let cy = current[1];

    if (visited[cx][cy]) continue;
    visited[cx][cy] = true;

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        if (abs(dx) + abs(dy) !== 1) continue;

        let nx = cx + dx;
        let ny = cy + dy;

        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
          if (board[nx][ny] === 0) {
            // Found a liberty (empty spot)
            liberties.add(`${nx},${ny}`);
          } else if (board[nx][ny] === targetState && !visited[nx][ny]) {
            // Found another stone in the same group
            stack.push([nx, ny]);
          }
        }
      }
    }
  }
  return liberties.size;
}


function passTurn() {
  if (gameOver) return;
  currentPlayer = 3 - currentPlayer;
  passCount++;

  if (passCount >= 2) {
    gameOver = true;
  }
  updateUIStatus();
}

function clearBoard() {
  for (let i = 0; i < gridSize; i++) {
    for (let j = 0; j < gridSize; j++) {
      grid[i][j].state = 0;
      grid[i][j].lastMove = false;
      grid[i][j].isCurrentlyPlaying = false;
    }
  }

  currentPlayer = 1;
  passCount = 0;
  gameOver = false;
  koX = -1;
  koY = -1;
  sequence = [];
  currentSequenceIndex = 0;
  isPlayingSequence = false;
  
  drawGoBoard();
  updateUIStatus();
}

function playNote(x, y, player) {
  let noteIndex = (x + y) % 13;

  if (player === 1) { // Bass
    bassOsc.freq(bassFreqs[noteIndex]);
    bassOsc.start();
    setTimeout(() => { bassOsc.stop(); }, 300);
  } else { // Treble
    trebleOsc.freq(trebleFreqs[noteIndex]);
    trebleOsc.start();
    setTimeout(() => { trebleOsc.stop(); }, 200);
  }
}

function playNextInSequence() {
  if (sequence.length === 0) {
    // If sequence is cleared while playing, stop loop
    isPlayingSequence = false;
    updateUIStatus();
    return;
  }

  // Clear previous highlights
  for (let cell of sequence) {
    cell.isCurrentlyPlaying = false;
  }

  // Play current note
  let currentCell = sequence[currentSequenceIndex];
  if (currentCell.state !== 0) {
      currentCell.isCurrentlyPlaying = true;
      playNote(currentCell.x, currentCell.y, currentCell.state);
  }

  // Move to next position (loop back to start)
  currentSequenceIndex = (currentSequenceIndex + 1) % sequence.length;
}

function toggleSequencePlayback() {
  isPlayingSequence = !isPlayingSequence;
  if (isPlayingSequence) {
    currentSequenceIndex = 0;
    lastPlayTime = millis();
  }
  updateUIStatus();
}


// Cell class
class Cell {
  constructor(x, y, cellSize) {
    this.x = x; // Grid X (0-12)
    this.y = y; // Grid Y (0-12)
    this.state = 0; // 0=empty, 1=bass, 2=treble
    this.lastMove = false;
    this.isCurrentlyPlaying = false;
  }

  display() {
    let px = (this.x + 1) * cellSize;
    let py = (this.y + 1) * cellSize;

    // Highlight currently playing note
    if (this.isCurrentlyPlaying) {
      noStroke();
      fill(sequenceHighlightColor);
      ellipse(px, py, cellSize * 0.9);
    }
    
    // Highlight last move
    if (this.lastMove) {
      noStroke();
      fill(lastMoveColor);
      ellipse(px, py, cellSize * 0.85);
    }

    // Draw the stone
    noStroke();
    if (this.state === 1) {
      fill(bassColor);
    } else {
      fill(trebleColor);
      stroke(150);
      strokeWeight(0.5);
    }
    ellipse(px, py, cellSize * 0.8);
  }
}
</script>
  </div>
  
</body>
</html>